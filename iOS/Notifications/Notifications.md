# User Notifications

User facing notifications play an important role in communicating users of apps important information about some events
they might be interested in or about some event in the app they might need to know about.


## Benefits
Using push notifications can have below benefits
- Updates
- Dynamic experience
- Increased user engagement
- Being push, these do not require app to be in foreground
- Push notifications are power efficient

User notifications can be
- Local Notifications
- Remote Notifications


## Local Notifications
App can generate notifications locally by specifying the content and condition for delivery like time or location which
will trigger the application. User can change authorization status anytime so before scheduling a local notification one
should always check the status.


## Remote Notifications
Remote notifications are trigerred from a provider via APNs i.e. Apple Push Notification service. If an app supports
remote notifications then app needs to have a provider server. This provider server will actually talk to APNs and request
for notification which APNs will further publish to App. So when there is a notification to send, the provider server
must construct a POST request and send it to APNs.

The POST request should contain following :
- JSON Payload
- Device token of user's device
- Request header fields
- Provider's current auth token (if token based authentication) This authentication 
is for provider server to be authenticated.


## Reasons for push notifications failure
1. Some failed logic at provider server.
2. Push certificate expiry.
3. Wrong/Invalid or expired device token.
4. User has turned off permission to receive push notifications.
5. User's device on DND(Do not disturb)
6. Device in low power mode.
7. Authentication issues between provider server and APNs
8. Payload size issues


## What is device token?
A device token is generated by APNs servers once user authorizes app to use push notifications. This device token
uniquely identifies an app for a particular device.

## How to receive device token?
An app in order to opt for push notifications need to request authorisation from user. Once authorisation is granted and
app is successfully registered with APNs, UIKit will call following method on delegate:

```
application(_:didRegisterForRemoteNotificationsWithDeviceToken:)
```

One needs to take device token received in this delegate callback and send it to the app's provider server.

## Can device token be cached at device?
NO, one should not cache device token at device. It should be sent to provider server once received. Caching at device doesn't
serves any purpose as device token can be periodically changed.


## registerForRemoteNotifications() vs requestAuthorization(options:completionHandler:), which sequence these are called?
As per official documentation from Apple one should register app and receive device token each time app launches. This
indicates best place to put registerForRemoteNotifications() should be in AppDelegate's *application(_:didFinishLaunchingWithOptions:)* method. This makes sense as documentations also recommends never to cache device tokens
in device's local storage, as APNs can issue a new token unders some scenarios, so asking each time for registration provides
one an always up-to-date token.

Reference : https://developer.apple.com/documentation/usernotifications/registering-your-app-with-apns

Now this takes to next part of the problem, that should one need to ask for permission before or after registering.
As per below documentation for registerForRemoteNotifications() method, registration is necessary to receive notifications
so that needs to be done first and foremost. Now asking for user's permission is required so as to enable remote notifications
to display alerts, sound, etc. So registration is important as without that device won't be able to receive any notification
as the provider server needs to have device token in order to ask APNs to send notifications.
Now once device is registered, without any authorisation from user if any notification is sent then the system will treat
all notifications as silent notifications and delivers them silently.
So after registration is done one should ask for authorisation at some appropriate point in app's flow where it makes sense
so that the user knows the context in which app will give notifications.
https://developer.apple.com/documentation/uikit/uiapplication/1623078-registerforremotenotifications


## Request Authorization

Before starting to push notifications to app, the app must ask for permissions to use notifications, basically asking
user's consent for getting these notifications. Consent is required because user might consider notification based
interactions as disruptions, so permission must be obtained.

To ask for permission one should get shared instance of UNUserNotificationCenter and call
requestAuthorization(options:completionHandler:) method.

This requests user's authorization to allow :
- Local notifications
- Remote notifications

```swift
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { granted, error in
            print("Permission granted: \(granted)")
        }
```

## New : WWDC 2023

### Push Notifications Console
- Send notifications
    One can configure and send a push notification using Push Notifications Console.
    This console also keeps a history of notifications sent, which can be edited and send again.
    
- Examine delivery logs
    This is required to analyze cases when a notification sent isn't received. The events reflecting the delivery process
    for a notification as it travels through APNs are recorded. This information can be retrieved now using the header
    returned from APNs(**apns-unique-id**) when notification is sent. There is a delivery log tab in push notification
    console where this apns-unique-id can be searched to see detailed logs to understand what happened with notification.
    
- Debug with tools
    Push Notifications Console comes with tool to generate APNs authentication token by providing the private key
    generated form apple developer portal. Validity of these token cannot exceed more than 1 hour.
    
    There is a token validation tool as well which will validate the above generated token.
    
    There is a device token validator.
    

## APNs Authentication

- Certificate based (SSL certificate)
- Token based (JSON based web token)

### Note
1. Always request for authorization before registering with Apple Push Notification service. THIS POINT APPEARS
CONTRADICTORY AS PER APPLE'S DOCUMENTATION REGARDING REGISTRATION AND AUTHORISATION.

2. Authorization should NOT be blindly requested at app launch, instead it should be asked in a context which helps
user understand why app needs authorization. It's not necessary or desirable to request for authorization on app
launch itself. This ideally should be asked within some relvant context so as to give user more insight of what
notification will be like. 
For e.g. suppose a grocery app let's you add some available coupon codes, so when user adds a coupon that time request
can be made telling user that app can notify for coupons when available. This way user will get an understanding of why
and how the notification can be helpful to him/her and can take informed decision.

3. First time authorization promp is shown and user's response is recorded, subsequent calls for authorization doesn't
show prompt again, unless app is deleted from device.

4. User at anytime can go to settings app and change the configurations for push notifications.
UNUserNotificationCenter's getNotificationSettings(completionHandler:) can be used to retrieve the authorization and feature-related settings.

### Explicit vs Provisional authorization

An explicit authorization will prompt user to decide if they want to receive push
notifications or not. This user will have to decide even without actually seeing
any notification. So the decision may not be very informed one and might lead to
rejecting authorization itseld, it might actually help user to decide if they can 
see a notification and then take decision.

This is where provisional authorization comes into play. While requesting for
authorization one can use provisional option as below :

Note: This method won't prompt user when used with provisional option, instead
it will grant permission automatically.

```swift
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound, .provisional]) { granted, error in
            print("Provisional permission granted: \(granted)")
        }
```
 
Now what will happen in case of a provisional notification is that system will deliver
provisional notifications quietly. Quietly means
- no sound
- no banner
- not appear on lock screen
Instead these notifications will only appear in notification center's history. These
notifications along with content will also display two buttons
- Keep
    - Prominent
    - Quiet
- Turn off

## Check App's authorization status

User can anytime alter app's authorization for receiving notifications view Settings
app. Thus it's important to check app's current authorization settings before for 
eg sceduling a local notification.

```swift
let center = UNUserNotificationCenter.current()
center.getNotificationSettings { settings in
    guard (settings.authorizationStatus == .authorized) ||
          (settings.authorizationStatus == .provisional) else { return }


    if settings.alertSetting == .enabled {
        // Schedule an alert-only notification.
    } else {
        // Schedule a notification with a badge and sound.
    }
}
```

## Actionable notifications

Usually notifications display the information as per payload received from APNs,
user's only action is to view or launch the app.
Actionable notifications enable user to respond to a received notification without
launching the app. Along with notification, system will display one or more buttons.
Tapping these buttons will send selected action to app. The action is then processed
in background.

Supporting actionable notifications include below steps:
1. Declaring one or more notification categories (UNNotificationCategory)
2. Assign required actions to categories (UNNotificationAction)
3. Handle actions (UNUserNotificationCenterDelegate)
4. Assign declared categories to notification payloads

```swift
    func scheduleActionableLocalNotification() {
        let goodAction = UNNotificationAction(identifier: "actionableLocalNotification.goodAction", title: "Good")
        let badAction = UNNotificationAction(identifier: "actionableLocalNotification.badAction", title: "Bad")
        let actionableLocalNotificationCategory = UNNotificationCategory(identifier: "actionableLocalNotificationCategory",
                                                                         actions: [goodAction, badAction],
                                                                         intentIdentifiers: [])
        UNUserNotificationCenter.current().setNotificationCategories([actionableLocalNotificationCategory])
        
        let notificationContent = UNMutableNotificationContent()
        notificationContent.title = "An actionable local notification"
        notificationContent.subtitle = "This is example of an actionable local notification. We simply ask user how's user feeling, Good or Bad"
        notificationContent.categoryIdentifier = "actionableLocalNotificationCategory"
        
        let notificationTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 10, repeats: false)
        let notificationRequest = UNNotificationRequest(identifier: UUID().uuidString,
                                                        content: notificationContent,
                                                        trigger: notificationTrigger)
        
        UNUserNotificationCenter.current().add(notificationRequest)
    }
```

### Note: Quoting from Apple Docs 
_All of your action objects must have unique identifiers. When handling actions, 
the identifier is the only way to distinguish one action from another, even when 
those actions belong to different categories._

## Notification management players

### UNUserNotificationCenter

UNUserNotificationCenter is central object which manages notification related activities
for app or app extension. It's role includes :

1. Request authorization
2. Declare notification types app supports
3. Schedule local notification delivery
4. Process remote notifications payload
5. Manage delivered notifications
6. Handle user-selected actions from custom notifications


## Silent Notifications
Silent notifications are the notifications which are sent to devices but without activating any sound, alert or badge the
app icon. Purpose of these notifications is to silently wake up the app and perform some operation in background.

### Use Case
1. Suppose an app depends on some backend data which needs frequent updates, one way to make sure user doesn't miss out
on important updates is to push a silent notification which wakes up app and makes necessary API calls.

### Are silent and background notifications same?
There is no mention of silent notifications in Apple's documentation. The only documentation available mentions the
notifications as background notifications, refer:

https://developer.apple.com/documentation/usernotifications/pushing-background-updates-to-your-app

It appears silent and background notifications are same.

TODO: Need to explore and confirm this point.

### What happens when app receives a silent/background notification


## Can a push notification contain a universal link or deeplink?
YES. One need to set-up the payload of notification to include the URL and then when notification is received, at app end
logic need to be added to identify if notification contains deeplink/universal link and then take appropriate action.


## How to modify content of notifications?
To modify content of notifications one have option of *UNNotificationServiceExtension* and *UNNotificationContentExtension*


## Notifications extension types

### Notification Service Extension
Notification Service Extension type target when added to project provides object of type *UNNotificationServiceExtension*.
This object, *UNNotificationServiceExtension*, gives an entry point and enables to customize contents of a push notification
BEFORE it is delivered.
This extension can be used to
- Modify content of a notification
- Download content related to notification
- Perform any required encryption/decryption of notification's content

Requirement:
The payload should contain dictionary key *mutable-content* with value set to 1.

### Notification Content Extension : iOS ONLY
Notification Content Extension customizes the appearance of push notification alerts for iOS App.
When notification content extention type target is added to an iOS app, it adds a viewcontroller conforming to protocol
*UNNotificationContentExtension*.
*UNNotificationContentExtension* protocol conforming viewcontroller provides the custom user interface one needs to use
for notifications.


|Type|Notification Service Extension|Notification Content Extension|
|---|---|---|
||UNNotificationServiceExtension|UNNotificationContentExtension|
|Purpose|Modify content of push notification|Customize appearance of push notification|
|Context|Acts before notification is delivered by system to user|Acts when notification is displayed|
|Use cases|Modify content, encrypt/decrypt, download media etc|Rich UI, custom buttons, custom fonts|
|Lifecycle|Short lifespan of 30 seconds|Active while notification is expanded|